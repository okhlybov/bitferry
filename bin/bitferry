#!/usr/bin/env ruby


require 'gli'


require 'bitferry'


include Bitferry


extend GLI::App


program_desc 'File synchronization/backup automation tool'


version Bitferry::VERSION


arguments :strict
subcommand_option_handling :normal


desc 'Be as quiet as possible'
switch [:quiet, :q], { negatable: false }


desc 'Debug mode with lots of information'
switch :debug, { negatable: false }


desc 'Show status information'
command [:show, :info] do |c|
  c.action do
    unless (xs = Volume.intact).empty?
      puts '# Intact volumes'
      puts
      xs.each do |volume|
        puts "  #{volume.tag}    #{volume.root}"
      end
    end
    unless (xs = Task.intact).empty?
      puts
      puts '# Intact tasks'
      puts
      xs.each do |task|
        puts "  #{task.tag}    #{task.to_show}"
      end
    end
    unless (xs = Task.stale).empty?
      puts
      puts '# Stale tasks'
      puts
      xs.each do |task|
        puts "  #{task.tag}    #{task.to_show}"
      end
    end
  end
end


def decode_endpoint(root)
  x = Volume.endpoint(root)
  raise ArgumentError, "No intact volume encompasses specified path #{root}" if x.nil?
  x
end


def create_task(task, *args, **kws)
  begin
    task.new(decode_endpoint(args[0]), decode_endpoint(args[1]))
    true
  rescue => e
    log.error(e.message)
    false
  end
end


desc 'Create entity (volume, task)'
command [:new, :create] do |c|


  c.arg 'root'
  c.desc 'Create new volume'
  c.command :volume do |e|
    e.switch :force, { desc: 'Allow overwriting existing volume storage', negatable: false }
    e.action do |gopts, opts, args|
      Volume.force_overwrite = opts[:force]
      Volume.new(args.first)
    end
  end


  c.desc 'Create new task'
  c.command :task do |e|


  def self.new_task_args(x)
    x.arg '[local:]source'
    x.arg '[local:]destination'
  end


  new_task_args e
  e.desc 'Create new copy task'
  e.command :copy do |t|
    t.action do |gopts, opts, args|
      create_task(Rclone::Copy, *args)
    end
  end


  new_task_args e
  e.desc 'Create new update task'
  e.command :update do |t|
    t.action do |gopts, opts, args|
      create_task(Rclone::Update, *args)
    end
  end
end


end


desc 'Delete entity (volume, task)'
command [:delete, :remove] do |c|


  def self.delete_args(x)
    x.arg 'tag', :multiple
  end


  delete_args(c)
  c.desc 'Delete volume'
  c.command :volume do |e|
    e.action do |gopts, opts, args|
    end
  end


  delete_args(c)
  c.desc 'Delete task'
  c.command :task do |e|
    e.action do |gopts, opts, args|
    end
  end
end


pre do |gopts, cmd, opts, args|
  Bitferry.log.level = Logger::DEBUG if gopts[:debug]
  Bitferry.restore
end


post do |gopts, cmd, opts, args|
  Bitferry.commit
end


exit !run(ARGV)