#!/usr/bin/env ruby


require 'gli'


include GLI::App


require 'bitferry'


include Bitferry


$failure = false


program_desc 'File synchronization/backup automation tool'


version Bitferry::VERSION


arguments :strict
subcommand_option_handling :normal


desc 'Be as quiet as possible'
switch [:quiet, :q], { negatable: false }


desc 'Be more verbose'
switch [:verbose, :v], { negatable: false }


desc 'Simulation mode (make no on-disk changes)'
switch ['dry-run', :n], { negatable: false }


desc 'Debug mode with lots of information'
switch [:debug, :d], { negatable: false }


desc 'Show status information'
command [:show, :info] do |c|
  c.action do
    unless (xs = Volume.intact).empty?
      puts '# Intact volumes'
      puts
      xs.each do |volume|
        puts "  #{volume.tag}    #{volume.root}"
      end
    end
    unless (xs = Task.intact).empty?
      puts
      puts '# Intact tasks'
      puts
      xs.each do |task|
        puts "  #{task.tag}    #{task.to_show}"
      end
    end
    unless (xs = Task.stale).empty?
      puts
      puts '# Stale tasks'
      puts
      xs.each do |task|
        puts "  #{task.tag}    #{task.to_show}"
      end
    end
  end
end


desc 'Process intact tasks'
command :process do |p|
  p.action { $failure = true unless Bitferry.process }
end


def decode_endpoint(root)
  x = Bitferry.endpoint(root)
  raise ArgumentError, "no volume encompasses specified path #{root}" if x.nil?
  x
end


desc 'Create entity (volume, task)'
command [:new, :create] do |c|


  c.arg 'root'
  c.desc 'Create new volume'
  c.command :volume do |e|
    e.switch :force, { desc: 'Allow overwriting existing volume storage', negatable: false }
    e.action do |gopts, opts, args|
      Volume.force_overwrite = true if opts[:force]
      Volume.new(args.first)
    end
  end


  def create_task(task, *args, **opts)
    begin
      m = encryption_mode(**opts)
      x = m.nil? ? nil : Rclone::Encryption.new(m, '1 23')
      task.new(decode_endpoint(args[0]), decode_endpoint(args[1]), encryption: x)
    rescue => e
      log.error(e.message)
      raise
    end
  end
  
  
  def self.new_task_args(x)
    x.arg '[remote:]source'
    x.arg '[remote:]destination'
  end


  def self.new_task_opts(x)
    x.switch [:encrypt, :e], { desc: 'Encrypt destination files', negatable: false }
    x.switch [:decrypt, :d], { desc: 'Decrypt source files', negatable: false }
  end
  
  
  def self.encryption_mode(**opts)
    mode = nil
    [:encrypt, :decrypt].each do |m|
      if opts[m]
        if mode.nil?
          mode = m
        else
          raise "expected only one encryption mode specifier"
        end
      end
    end
    mode
  end


  c.desc 'Create new task'
  c.command :task do |e|


  new_task_args e
  e.desc 'Create new copy task'
  e.command :copy do |t|
    new_task_opts t
    t.action do |gopts, opts, args|
      create_task(Rclone::Copy, *args, **opts)
    end
  end


  new_task_args e
  e.desc 'Create new update task'
  e.command :update do |t|
    new_task_opts t
    t.action do |gopts, opts, args|
    create_task(Rclone::Update, *args, **opts)
  end
  end
end


end


desc 'Delete entity (volume, task)'
command [:delete, :remove] do |c|


  def self.delete_args(x)
    x.arg 'tag', :multiple
  end


  delete_args(c)
  c.desc 'Delete volume'
  c.command :volume do |e|
    e.switch :wipe, { desc: 'Wipe entire volume directory', negatable: false }
    e.action do |gopts, opts, args|
      Volume.force_wipe = true if opts[:wipe]
      args.each do |partial|
        volumes = Volume.lookup(partial)
        case volumes.size
        when 0 then log.warn("no volume matching (partial) tag #{partial}")
        when 1
        else
          tags = volumes.collect { |task| task.tag }
          log.fatal("multiple volumes matching (partial) tag #{partial}: #{tags.join(', ')}")
          raise
        end
        volumes.each(&:delete)
      end
    end
  end


  delete_args(c)
  c.desc 'Delete task'
  c.command :task do |e|
    e.action do |gopts, opts, args|
      args.each do |partial|
        tasks = Task.lookup(partial)
        case tasks.size
        when 0 then log.warn("no task matching (partial) tag #{partial}")
        when 1
        else
          tags = tasks.collect { |task| task.tag }
          log.fatal("multiple tasks matching (partial) tag #{partial}: #{tags.join(', ')}")
          raise
        end
        tasks.each(&:delete)
      end
    end
  end
end


pre do |gopts, cmd, opts, args|
  Bitferry.log.level = Logger::DEBUG if gopts[:debug] || $DEBUG
  Bitferry.simulate = true if gopts[:'dry-run']
  Bitferry.verbosity = :verbose if gopts[:verbose]
  Bitferry.verbosity = :quiet if gopts[:quiet]
  $failure = true unless Bitferry.restore
  true
end


post do |gopts, cmd, opts, args|
  $failure = true unless Bitferry.commit
  raise 'failure(s) reported' if $failure
  true
end


exit run(ARGV)